## 代码：创建地址空间
* main函数调用kvmalloc创建新的页表(这个新的页表其高地址映射到内核),并转向新的页表地址空间。其中大部分工作在setupkvm中完成。setupkvm首先分配一个页的内存来装页目录表,然后调用mappages安装内核所需要的页目录项,这些页目录项存放在数组kmap里。页目录项包含内核的指令和数据,最大值为PHYSTOP的物理地址,还有映射到内存空间的I/O设备。setupkvm不映射属于用户的页表项,那会在接来的内容中讲到。
* mappages函数将虚拟地址和物理地址关联起来形成映射。它按照每个页分别处理,亦即一个虚拟页会被映射到一个物理页帧。对于每一个要映射到物理地址的虚拟地址页,mappages调用walkpgdir先找到该虚拟地址对应的页表项(PTE),然后将相关的物理页帧号、所需要的权限、有效位等装入该页表项。
* walkpgdir模拟x86分页硬件的动作,在页表中寻找虚拟地址高几位对应的页表项:先用高10位作为索引去寻找页目录表中的页目录项,如果该项无效,则说明该项所对应的页表尚未分配。如果设置了alloc参数,walkpgdir就会分配一个页表并将该页表的物理地址填入页目录表中对应的页目录项。最终，walkpgdir使用虚拟地址接下来的10位作为索引在页表中找寻对应的页表项。
## 物理内存分配
* 内核必须在运行时位页表、进程用户内存、进程内核栈、管道缓冲区等**分配和释放**物理内存。xv6将内核结尾处到PHYSTOP之间的物理内存用于运行时分配。xv6通过一个**空闲链表**管理空闲页，那么分配动作要包含在空闲链表上移除要分配页的操作,释放动作要包含将要释放的页加入到空闲链表的操作。
* 有一个自举的问题：所有的物理内存必须映射，以便分配器初始化空闲链表。创建包含这些映射的页表涉及分配页表页面。xv6通过在entry中使用一个单独的分配器来解决这个问题，紧跟在内核数据段之后分配内存。